概述：clang LLVM 编译器

用法：clang [选项] 文件...

选项：
  -### 打印（但不运行）要为此编译运行的命令
  --amdgpu-arch-tool=<值>
                          用于检测系统中 AMD GPU arch 的工具。
  --analyzer-output <值>
                          静态分析器报告输出格式（html|plist|plist-multi-file|plist-html|sarif|sarif-html|text）。
  --analyze 运行静态分析器
  -arcmt-migrate-emit-errors
                          即使迁移者可以修复它们，也会发出 ARC 错误
  -arcmt-migrate-report-output <值>
                          plist 报告的输出路径
  -B <prefix> 在 $prefix/$triple-$file 和 $prefix$file 中搜索编译器使用的可执行文件、库、包含和数据文件。 $prefix 可能是也可能不是目录
  -CC 在预处理输出中包含宏内的注释
  -cl-denorms-are-zero 仅限 OpenCL。允许非正规数刷新为零。
  -cl-fast-relaxed-math 仅限 OpenCL。设置 -cl-finite-math-only 和 -cl-unsafe-math-optimizations，并定义 __FAST_RELAXED_MATH__。
  -cl-finite-math-only 仅限 OpenCL。允许假定参数和结果不是 NaN 或 +-Inf 的浮点优化。
  -cl-fp32-correctly-rounded-divide-sqrt
                          仅限 OpenCL。指定程序源中使用的单精度浮点除法和 sqrt 正确舍入。
  -cl-kernel-arg-info 仅限 OpenCL。生成内核参数元数据。
  -cl-mad-仅启用 OpenCL。允许在生成的二进制文件中使用不太精确的 MAD 计算。
  -cl-no-signed-zeros 仅限 OpenCL。允许在生成的二进制文件中使用不太精确的无符号零计算。
  -cl-no-stdinc 仅限 OpenCL。禁用所有标准包括包含非本地编译器类型和函数。
  -cl-opt-仅禁用 OpenCL。此选项禁用所有优化。默认情况下启用优化。
  -cl-单精度常数
                          仅限 OpenCL。将双精度浮点常量视为单精度常量。
  -cl-std=<value> 要编译的 OpenCL 语言标准。
  -cl-strict-aliasing 仅限 OpenCL。添加此选项是为了与 OpenCL 1.0 兼容。
  -cl-uniform-work-group-size
                          仅限 OpenCL。定义全局工作大小是指定给 clEnqueueNDRangeKernel 的工作组大小的倍数
  -cl-unsafe-math-optimizations
                          仅限 OpenCL。允许不安全的浮点优化。还暗示 -cl-no-signed-zeros 和 -cl-mad-enable。
  --config <value> 指定配置文件
  --cuda-compile-host-device
                          为主机和设备编译 CUDA 代码（默认）。对非 CUDA 编译没有影响。
  --cuda-device-only 只为设备编译 CUDA 代码
  --cuda-host-only 仅为主机编译 CUDA 代码。对非 CUDA 编译没有影响。
  --cuda-include-ptx=<值>
                          为以下 GPU 架构（例如 sm_35）或“全部”包含 PTX。可以多次指定。
  --cuda-noopt-device-debug
                          启用设备端调试信息生成。禁用 ptxas 优化。
  --cuda-path-ignore-env 忽略环境变量来检测 CUDA 安装
  --cuda-path=<value> CUDA 安装路径
  -cuid=<value> 编译单元的ID，同一个编译单元应该相同，不同编译单元应该不同。它用于将单源卸载语言 CUDA 和 HIP 的设备端静态变量外部化，以便它们可以被同一编译单元的主机代码访问。
  -cxx-isystem <目录>
                          将目录添加到 C++ SYSTEM 包含搜索路径
  -C 在预处理输出中包含注释
  -c 只运行预处理、编译和组装步骤
  -dD 除正常输出外，还以 -E 模式打印宏定义
  -dependency-dot <value> 将 DOT 格式的头依赖项写入到的文件名
  -dependency-file <值>
                          将依赖项输出写入的文件名（或 -）
  -dI 在 -E 模式下打印包含指令以及正常输出
  -dM 在 -E 模式下打印宏定义而不是正常输出
  -dsym-dir <dir> 输出 dSYM（如果有）的目录
  -D <macro>=<value> 将 <macro> 定义为 <value>（如果 <value> 省略，则为 1）
  -emit-ast 为源输入发出 Clang AST 文件
  -emit-interface-stubs 生成接口存根文件。
  -emit-llvm 对汇编程序和目标文件使用 LLVM 表示
  -emit-merged-ifs 生成接口存根文件，发出合并文本而不是二进制文件。
  --emit-static-lib 启用链接器作业以发出静态库。
  -enable-trivial-auto-var-init-zero-knowing-it-will-removed-from-clang
                          微不足道的自动变量初始化为零仅用于基准测试，它最终会被删除，我对此没意见，因为我只使用它来进行基准测试
  -E 只运行预处理器
  -faapcs-bitfield-load 遵循 AAPCS 标准，所有易失性位字段写入至少生成一个负载。 （仅限 ARM）。
  -faapcs-bitfield-width 遵循 AAPCS 标准要求，说明易失性位字段宽度由字段容器类型决定。 （仅限 ARM）。
  -faccess-control
  -faddrsig 发出地址重要性表
  -faligned-allocation 启用 C++17 对齐分配函数
  -休假编辑占位符
                          将编辑器占位符视为有效的源代码
  -faltivec-src-compat=<值>
                          Altivec 矢量的源代码级兼容性（针对 PowerPC 目标）。这包括向量比较的结果（'xl' 的标量，'gcc' 的向量）以及用标量初始化时的行为（'xl' 的 splatting，'gcc' 的元素零）。对于“混合”，“矢量布尔/矢量像素”的兼容性为“gcc”，其他类型的兼容性为“xl”。当前默认值为“混合”。
  -fansi-escape-codes 使用 ANSI 转义码进行诊断
  -fapple-kext 使用苹果的内核扩展 ABI
  -fapple-link-rtlib 强制链接 clang 内置运行时库
  -fapple-pragma-pack 启用 Apple gcc-compatible #pragma pack 处理
  -fapplication-extension 将代码限制为可用于应用扩展的代码
  -fasm-blocks
  -fasync-exceptions 启用 EH 异步异常
  -fautolink
  -fbasic-block-sections=<值>
                          将每个函数的基本块放在唯一的部分（仅限 ELF）：全部 |标签|无 |列表=<文件>
  -fbinutils-version=<major.minor>
                          生成的目标文件可以使用此 binutils 版本和更新版本支持的所有 ELF 功能。如果指定了 -fno-integrated-as，则生成的程序集会将 GNU 视为支持。 'none' 意味着可以使用所有 ELF 功能，而不管 binutils 是否支持。默认为 2.26。
  -fblocks 启用“blocks”语言功能
  -fborland-extensions 接受 Borland 编译器支持的非标准结构
  -fbuild-session-file=<文件>
                          使用 <file> 的最后修改时间作为构建会话时间戳
  -fbuild-session-timestamp=<自纪元以来的时间（以秒为单位）>
                          当前构建会话开始的时间
  -fbuiltin-module-map 加载 clang 内置模块映射文件。
  -fc++-abi=<value> 要使用的 C++ ABI。这将覆盖目标 C++ ABI。
  -fc++-静态析构函数

  -fcall-saved-x10 保存 x10 寄存器调用（仅限 AArch64）
  -fcall-saved-x11 使 x11 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x12 保存 x12 寄存器调用（仅限 AArch64）
  -fcall-saved-x13 保存 x13 寄存器调用（仅限 AArch64）
  -fcall-saved-x14 保存 x14 寄存器调用（仅限 AArch64）
  -fcall-saved-x15 保存 x15 寄存器调用（仅限 AArch64）
  -fcall-saved-x18 保存 x18 寄存器调用（仅限 AArch64）
  -fcall-saved-x8 保存 x8 寄存器调用（仅限 AArch64）
  -fcall-saved-x9 保存 x9 寄存器调用（仅限 AArch64）
  -fcaret-诊断
  -fcf-protection=<value> 仪器控制流架构保护。选项：返回、分支、完整、无。
  -fcf-protection 在“完整”模式下启用 cf-protection
  -fchar8_t 启用 C++ 内置类型 char8_t
  -fclang-abi-compat=<版本>
                          尝试匹配 Clang <version> 的 ABI
  -fcolor-diagnostics 在诊断中启用颜色
  -fcomment-block-commands=<参数>
                          将 <arg> 中的每个逗号分隔参数视为文档注释块命令
  -fcommon 将未初始化的全局变量放在公共块中
  -fcomplete-member-pointers
                          如果成员指针基类型在 Microsoft ABI 下很重要，则要求成员指针基类型是完整的
  -fconstant-cfstrings
  -fconvergent-functions 假设函数可能收敛
  -fcoroutines-ts 启用对 C++ 协程 TS 的支持
  -fcoverage-compilation-dir=<值>
                          要嵌入覆盖映射的编译目录。
  -fcoverage-mapping 生成覆盖映射以启用代码覆盖分析
  -fcoverage-prefix-map=<值>
                          在覆盖映射中重新映射文​​件源路径
  -fcrash-diagnostics-dir=<目录>
                          将崩溃报告文件放在 <dir> 中
  -fcs-profile-generate=<目录>
                          生成检测代码以将上下文敏感的执行计数收集到 <directory>/default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fcs-profile-generate 生成检测代码以将上下文敏感的执行计数收集到 default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fcuda-approx-transcendentals
                          使用近似超越函数
  -fcuda-short-ptr 使用 32 位指针访问常量/本地/共享地址空间
  -fcxx-exceptions 启用 C++ 异常
  -fdata-sections 将每个数据放在自己的部分
  -fdebug-compilation-dir=<值>
                          要嵌入调试信息的编译目录
  -fdebug-default-version=<值>
                          要使用的默认 DWARF 版本，如果 -g 选项导致生成 DWARF 调试信息
  -fdebug-info-for-profiling
                          发出额外的调试信息以使样本配置文件更准确
  -fdebug-macro 发出宏调试信息
  -fdebug-prefix-map=<值>
                          在调试信息中重新映射文​​件源路径
  -fdebug-ranges-base-address
                          在 .debug_ranges 中使用 DWARF 基地址选择条目
  -fdebug-types-section 将调试类型放在它们自己的部分中（仅限 ELF）
  -fdeclspec 允许 __declspec 作为关键字
  -fdelayed-模板解析
                          在翻译单元的末尾解析模板化函数定义
  -fdelete-空指针检查
                          将空指针的使用视为未定义行为（默认）
  -fdiagnostics-absolute-paths
                          在诊断中打印绝对路径
  -fdiagnostics-hotness-threshold=<值>
                          如果优化评论没有至少此配置文件计数，则防止输出优化评论。使用“自动”应用配置文件摘要中的阈值
  -fdiagnostics-parseable-fixits
                          以机器可解析的形式打印 fix-its
  -fdiagnostics-print-source-range-info
                          以数字形式打印源范围跨度
  -fdiagnostics-show-hotness
                          在诊断行中启用配置文件热度信息
  -fdiagnostics-show-note-include-stack
                          显示包括诊断说明的堆栈
  -fdiagnostics-show-option
                          带有可映射诊断的打印选项名称
  -fdiagnostics-show-template-tree
                          打印不同模板的模板比较树
  -fdigraphs 启用替代标记表示 '<:', ':>', '<%', '%>', '%:', '%:%:'（默认）
  -fdirect-access-external-data
                          不要使用 GOT 间接引用外部数据符号
  -fdiscard-value-names 丢弃 LLVM IR 中的值名称
  -fdollars-in-identifiers
                          允许在标识符中使用“$”
  -fdouble-square-bracket-attributes
                          在所有 C 和 C++ 语言模式中启用“[[]]”属性
  -fdwarf-directory-asm
  -fdwarf-exceptions 使用 DWARF 风格的异常
  -felide-构造函数
  -feliminate-unused-debug-types
                          不要为已定义但未使用的类型发出调试信息
  -fembed-bitcode-marker 嵌入占位符 LLVM IR 数据作为标记
  -fembed-bitcode=<选项>
                          嵌入 LLVM 位码（选项：关闭、全部、位码、标记）
  -fembed-bitcode 嵌入 LLVM IR 位码作为数据
  -femit-all-decls 发出所有声明，即使未使用
  -femulated-tls 使用 emutls 函数访问 thread_local 变量
  -fenable-matrix 启用矩阵数据类型和相关的内置函数
  -fescaping-block-tail-calls

  -fexceptions 启用对异常处理的支持
  -fexperimental-new-constant-interpreter
                          启用实验性的新常量解释器
  -fexperimental-relative-c++-abi-vtables
                          将实验性 C++ 类 ABI 用于具有虚拟表的类
  -fexperimental-strict-floating-point
                          在 LLVM 中启用实验性严格浮点。
  -fextend-arguments=<值>
                          控制如何在调用非原型和可变参数函数时扩展标量整数参数
  -ffast-math 允许积极的、有损的浮点优化
  -ffile-compilation-dir=<值>
                          要嵌入调试信息和覆盖映射的编译目录。
  -ffile-prefix-map=<值>
                          在调试信息、预定义的预处理器宏和 __builtin_FILE() 中重新映射文​​件源路径
  -细粒度位域访问
                          对具有合法宽度和对齐方式的连续位域运行使用单独的访问。
  -ffinite-loops 假设所有循环都是有限的。
  -finite-math-only
  -ffixed-a0 保留 a0 寄存器（仅限 M68k）
  -ffixed-a1 保留 a1 寄存器（仅限 M68k）
  -ffixed-a2 保留 a2 寄存器（仅限 M68k）
  -ffixed-a3 保留 a3 寄存器（仅限 M68k）
  -ffixed-a4 保留 a4 寄存器（仅限 M68k）
  -ffixed-a5 保留 a5 寄存器（仅限 M68k）
  -ffixed-a6 保留 a6 寄存器（仅限 M68k）
  -ffixed-d0 保留 d0 寄存器（仅限 M68k）
  -ffixed-d1 保留 d1 寄存器（仅限 M68k）
  -ffixed-d2 保留 d2 寄存器（仅限 M68k）
  -ffixed-d3 保留 d3 寄存器（仅限 M68k）
  -ffixed-d4 保留 d4 寄存器（仅限 M68k）
  -ffixed-d5 保留 d5 寄存器（仅限 M68k）
  -ffixed-d6 保留 d6 寄存器（仅限 M68k）
  -ffixed-d7 保留 d7 寄存器（仅限 M68k）
  -ffixed-point 启用定点类型
  -ffixed-r19 保留寄存器 r19（仅限六边形）
  -ffixed-r9 保留 r9 寄存器（仅限 ARM）
  -ffixed-x10 保留 x10 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x11 保留 x11 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x12 保留 x12 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x13 保留 x13 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x14 保留 x14 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x15 保留 x15 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x16 保留 x16 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x17 保留 x17 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x18 保留 x18 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x19 保留 x19 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x1 保留 x1 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x20 保留 x20 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x21 保留 x21 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x22 保留 x22 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x23 保留 x23 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x24 保留 x24 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x25 保留 x25 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x26 保留 x26 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x27 保留 x27 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x28 保留 x28 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x29 保留 x29 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x2 保留 x2 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x30 保留 x30 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x31 保留 x31 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x3 保留 x3 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x4 保留 x4 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x5 保留 x5 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x6 保留 x6 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x7 保留 x7 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x8 保留 x8 寄存器（仅限 AArch64/RISC-V）
  -ffixed-x9 保留 x9 寄存器（仅限 AArch64/RISC-V）
  -fforce-dwarf-frame 总是发出调试帧部分
  -fforce-emit-vtables 发出更多的虚拟表以改善去虚拟化
  -fforce-enable-int128 启用对 int128_t 类型的支持
  -ffp-contract=<value> 形成融合的 FP 操作（例如 FMA）：快速（跨语句融合，无视编译指示）| on（除非由 pragma 指示，否则仅在同一语句中熔断） |关闭（从不熔断）| fast-honor-pragmas（除非由 pragma 指示，否则会在语句之间融合）。 CUDA 的默认值为“fast”，HIP 的默认值为“fast-honor-pragmas”，否则为“on”。
  -ffp-exception-behavior=<值>
                          指定浮点运算的异常行为。
  -ffp-model=<value> 控制浮点计算的语义。
  -ffreestanding 断言编译发生在独立环境中
  -ffunction-sections 将每个函数放在自己的部分
  -fglobal-isel 启用全局指令选择器
  -fgnu-inline-asm
  -fgnu-keywords 无论语言标准如何，都允许 GNU 扩展关键字
  -fgnu-runtime 生成与标准 GNU Objective-C 运行时兼容的输出
  -fgnu89-inline 使用 gnu89 内联语义
  -fgnuc-version=<value> 设置各种宏以声明与给定 GCC 版本的兼容性（默认为 4.2.1）
  -fgpu-allow-device-init 在 HIP 中允许设备端初始化功能（实验性）
  -fgpu-defer-diag 延迟 CUDA/HIP 的主机/设备相关诊断消息
  -fgpu-flush-denormals-to-zero
                          在 CUDA/HIP 设备模式下将非正规浮点值刷新为零。
  -fgpu-rdc 生成可重定位设备代码，也称为分离编译模式
  -fgpu-sanitize 为 AMDGPU 目标启用消毒剂
  -fhip-fp32-correctly-rounded-divide-sqrt
                          指定程序源中使用的单精度浮点除法和 sqrt 正确舍入（仅限 HIP 设备编译）
  -fhip-new-launch-api 为 HIP 使用新的内核启动 API
  -fignore-exceptions 启用对忽略异常处理构造的支持
  -fimplicit-module-maps 在文件系统中隐式搜索模块映射文件。
  -fimplic-modules
  -finline-functions 内联合适的函数
  -finline-hint-functions 被（显式或隐式）标记为内联的内联函数
  -finput-charset=<value> 指定源文件的默认字符集
  -finstrument-function-entry-bare
                          仅检测函数入口，内联后，没有检测调用的参数
  -finstrument-functions-after-inlining
                          类似于 -finstrument-functions，但在内联后插入调用
  -finstrument-functions 生成对仪器函数入口和出口的调用
  -fintegrated-as 启用集成汇编器
  -fintegrated-cc1 在进程内运行 cc1
  -fjump-tables 使用跳转表降低开关
  -fkeep-static-consts 如果未使用，则保留静态常量变量
  -flax-vector-conversions=<值>
                          启用隐式向量位转换
  -flegacy-pass-manager 在 LLVM 中使用旧的 pass manager
  -flto-jobs=<value> 控制 -flto=thin 的后端并行度（默认为 0 表示将根据检测到的 CPU 数量得出线程数）
  -flto=<value> 将 LTO 模式设置为“full”或“thin”
  -flto 在“完整”模式下启用 LTO
  -fmacro-prefix-map=<值>
                          在预定义的预处理器宏和 __builtin_FILE() 中重新映射文​​件源路径
  -fmath-errno 要求数学函数通过设置 errno 来指示错误
  -fmax-tokens=<value> -Wmax-tokens 的最大预处理令牌总数。
  -fmax-type-align=<值>
                          指定对缺乏明确对齐的指针强制执行的最大对齐
  -fmemory-profile=<目录>
                          启用堆内存分析并将结果转储到 <directory>
  -fmemory-profile 启用堆内存分析
  -fmerge-all-constants 允许合并常量
  -fmessage-length=<值>
                          格式化消息诊断，使其适合 N 列
  -fmodule-file=[<名称>=]<文件>
                          指定模块名称到预编译模块文件的映射，如果省略名称，则加载模块文件。
  -fmodule-map-file=<文件>
                          加载这个模块映射文件
  -fmodule-name=<name> 指定要构建的模块的名称
  -fmodules-cache-path=<目录>
                          指定模块缓存路径
  -fmodules-decluse 要求声明模块中使用的模块
  -fmodules-disable-diagnostic-validation
                          加载模块时禁用诊断选项验证
  -fmodules-ignore-macro=<值>
                          构建和加载模块时忽略给定宏的定义
  -fmodules-prune-after=<秒>
                          指定模块文件将被视为未使用的间隔（以秒为单位）
  -fmodules-prune-interval=<秒>
                          指定尝试修剪模块缓存之间的间隔（以秒为单位）
  -fmodules-search-all 搜索甚至未导入的模块以解析引用
  -fmodules-strict-decluse
                          像 -fmodules-decluse 但要求所有头文件都在模块中
  -fmodules-ts 启用对 C++ 模块 TS 的支持
  -fmodules-user-build-path <目录>
                          指定模块用户构建路径
  -fmodules-validate-input-files-content
                          如果 mtime 不同，则根据内容验证 PCM 输入文件
  -fmodules-validate-once-per-build-session
                          如果模块在此构建会话期间已成功验证或加载，则不要验证模块的输入文件
  -fmodules-validate-system-headers
                          在加载模块时验证模块所依赖的系统头文件
  -fmodules 启用“模块”语言功能
  -fms-compatibility-version=<值>
                          表示要在 _MSC_VER 中报告的 Microsoft 编译器版本号的点分隔值（0 = 不定义它（默认））
  -fms-compatibility 启用完全的 Microsoft Visual C++ 兼容性
  -fms-extensions 接受微软编译器支持的一些非标准结构
  -fmsc-version=<value> 要在 _MSC_VER 中报告的 Microsoft 编译器版本号（0 = 不定义它（默认））
  -fnew-alignment=<align> 指定由 '::operator new(size_t)' 保证的最大对齐
  -fno-aapcs-位域宽度
                          不要遵循 AAPCS 标准要求，该要求说明易失性位字段宽度由字段容器类型决定。 （仅限 ARM）。
  -fno-access-control 禁用 C++ 访问控制
  -fno-addrsig 不发出地址重要性表
  -fno 对齐分配
  -fno-allow-editor-placeholders

  -fno-apple-pragma-pack
  -fno-application-extension

  -fno-asm-blocks
  -fno-assume-sane-operator-new
                          不要假设 C++ 的全局操作符 new 不能为任何指针做别名
  -fno-async-exceptions
  -fno-autolink 禁用自动库链接的链接器指令的生成
  -fno-blocks
  -fno-borland-extensions
  -fno-builtin-<value> 禁用特定函数的隐式内置知识
  -fno-builtin 禁用函数的隐式内置知识
  -fno-c++-静态析构函数
                          禁用 C++ 静态析构函数注册
  -fno-caret-diagnostics
  -fno-char8_t 禁用 C++ 内置类型 char8_t
  -fno-color-diagnostics 在诊断中禁用颜色
  -fno-common 像普通定义一样编译通用全局变量
  -fno-complete-member-pointers
                          如果成员指针基类型在 Microsoft ABI 下很重要，则不要求它们是完整的
  -fno-constant-cfstrings 禁止创建 CodeFoundation 类型的常量字符串
  -fno-coroutines-ts
  -fno-coverage-mapping 禁用代码覆盖分析
  -fno-crash-diagnostics 禁用预处理源文件的自动生成和用于在叮当声崩溃期间重现的脚本
  -fno-cuda-approx-transcendentals
                          不要使用近似超越函数
  -fno-cuda-short-ptr
  -fno-cxx-异常
  -fno-data-sections
  -fno-debug-info-for-profiling

  -fno-debug-macro 不发出宏调试信息
  -fno-debug-ranges-base-address

  -fno-declspec 禁止 __declspec 作为关键字
  -fno-延迟模板解析
                          禁用延迟模板解析
  -fno-delete-null-pointer-checks
                          不要将空指针的使用视为未定义的行为
  -fno-diagnostics-fixit-info
                          不要在诊断中包含 fixit 信息
  -fno-diagnostics-show-hotness

  -fno-diagnostics-show-note-include-stack

  -fno-diagnostics-show-option

  -fno-digraphs 禁止替代标记表示 '<:', ':>', '<%', '%>', '%:', '%:%:'
  -fno-direct-access-external-data
                          使用 GOT 间接引用外部数据符号
  -fno-discard-value-names
                          不要丢弃 LLVM IR 中的值名称
  -fno-dollars-in-identifiers
                          禁止在标识符中使用“$”
  -fno-double-square-bracket-attributes
                          在所有 C 和 C++ 语言模式中禁用“[[]]”属性
  -fno-dwarf-directory-asm

  -fno-elide-constructors 禁用 C++ 复制构造函数省略
  -fno-elide-type 在打印诊断信息时不要省略类型
  -fno-eliminate-unused-debug-types
                          为已定义但未使用的类型发出调试信息
  -fno-emulated-tls
  -fno-escaping-block-tail-calls

  -fno-exceptions 禁用对异常处理的支持
  -fno-experimental-relative-c++-abi-vtables
                          不要将实验性 C++ 类 ABI 用于具有虚拟表的类
  -fno-fast-math
  -fno-fine-grained-bitfield-accesses
                          对连续位域运行使用大整数访问。
  -fno-finite-loops 不要假设任何循环都是有限的。
  -fno-finite-math-only
  -fno-fixed-point 禁用定点类型
  -fno-force-dwarf-frame
  -fno-force-emit-vtables
  -fno-force-enable-int128
                          禁用对 int128_t 类型的支持
  -fno-function-sections
  -fno-global-isel 禁用全局指令选择器
  -fno-gnu-inline-asm 禁用 GNU 风格的内联汇编
  -fno-gnu-keywords
  -fno-gnu89-inline
  -fno-gpu-allow-device-init
                          不允许在 HIP 中使用设备端初始化功能（实验性）
  -fno-gpu-defer-diag 不要延迟 CUDA/HIP 的主机/设备相关诊断消息
  -fno-gpu-rdc
  -fno-hip-fp32-correctly-rounded-divide-sqrt
                          不要指定程序源中使用的单精度浮点除法和 sqrt 正确舍入（仅限 HIP 设备编译）
  -fno-hip-new-launch-api 不要为 HIP 使用新的内核启动 API
  -fno-隐式模块
  -fno-integrated-as 禁用集成汇编器
  -fno-integrated-cc1 为每个 cc1 生成一个单独的进程
  -fno-jump-tables 不要使用跳转表来降低开关
  -fno-keep-static-consts 如果未使用，不要保留静态常量变量
  -fno-legacy-pass-manager
                          在 LLVM 中使用新的 pass manager
  -fno-lto 禁用 LTO 模式（默认）
  -fno-math-errno
  -fno-memory-profile 禁用堆内存分析
  -fno-merge-all-constants
                          禁止合并常量
  -fno-modules-decluse
  -fno-modules-search-all
  -fno-modules-validate-system-headers

  -fno-modules
  -fno-objc-arc-exceptions

  -fno-objc-convert-messages-to-runtime-calls

  -fno-objc-encode-cxx-class-template-spec

  -fno-对象异常
  -fno-objc-infer-related-result-type
                          不根据方法族推断 Objective-C 相关的结果类型
  -fno-offload-lto 为卸载编译禁用 LTO 模式（默认）
  -fno-openmp-target-new-runtime

  -fno-operator-names 不要将 C++ 运算符名称关键字视为运算符的同义词
  -fno-pascal-strings
  -fno-pch-codegen 假设将为 PCH 构建显式目标文件，不生成使用此 PCH 的代码
  -fno-pch-debuginfo 不要为从此 PCH 构建的目标文件中的类型生成调试信息，也不要在其他地方生成它们
  -fno-pch-instantiate-templates

  -fno-plt 使用 GOT 间接代替 PLT 进行外部函数调用（仅限 x86）
  -fno-prebuilt-implicit-modules

  -fno-preserve-as-comments
                          不要在内联汇编中保留注释
  -fno-profile-arcs
  -fno-profile-generate 禁用配置文件检测的生成。
  -fno-profile-instr-generate
                          禁用配置文件检测的生成。
  -fno-profile-instr-use 禁用使用检测数据进行配置文件引导的优化
  -fno-protect-parens
  -fno-pseudo-probe-for-profiling
                          不要为样品分析发射伪探针
  -fno-reciprocal-math
  -fno-register-global-dtors-with-atexit
                          不要使用 atexit 或 __cxa_atexit 来注册全局析构函数
  -fno-relaxed-template-template-args

  -fno-reroll-loops
  -fno-rewrite-imports
  -fno-rewrite-includes
  -fno-ropi
  -fno-rtlib-add-rpath 不要将带有体系结构特定资源目录的 -rpath 添加到链接器标志
  -fno-rtti-data 禁用生成 RTTI 数据
  -fno-rtti 禁止生成 rtti 信息
  -fno-rwpi
  -fno-sanitize-address-outline-instrumentation
                          对地址清理程序使用默认代码内联逻辑
  -fno-sanitize-address-poison-custom-array-cookie
                          在 AddressSanitizer 中使用自定义运算符 new[] 时禁用中毒数组 cookie
  -fno-sanitize-address-use-after-scope
                          在 AddressSanitizer 中禁用作用域后检测
  -fno-sanitize-address-use-odr-indicator
                          禁用 ODR 指标全局变量
  -fno-sanitize-cfi-canonical-jump-tables
                          不要使符号表中的跳转表地址规范
  -fno-sanitize-cfi-cross-dso
                          禁用跨 DSO 调用的控制流完整性 (CFI) 检查。
  -fno-sanitize-coverage=<值>
                          禁用消毒剂的覆盖检测功能
  -fno-sanitize-hwaddress-experimental-aliasing
                          在 HWAddressSanitizer 中禁用别名模式
  -fno-sanitize-ignorelist
                          不要将忽略列表文件用于消毒剂
  -fno-sanitize-memory-track-origins
                          在 MemorySanitizer 中禁用源跟踪
  -fno-sanitize-memory-use-after-dtor
                          在 MemorySanitizer 中禁用销毁后使用检测
  -fno-sanitize-minimal-runtime

  -fno-sanitize-recover=<值>
                          禁用指定消毒剂的恢复
  -fno-sanitize-stats 禁用消毒剂统计信息收集。
  -fno-sanitize-thread-atomics
                          在 ThreadSanitizer 中禁用原子操作检测
  -fno-sanitize-thread-func-entry-exit
                          在 ThreadSanitizer 中禁用函数进入/退出检测
  -fno-sanitize-thread-memory-access
                          在 ThreadSanitizer 中禁用内存访问检测
  -fno-sanitize-trap=<值>
                          禁用对指定消毒剂的捕获
  -fno-sanitize-trap 禁用所有消毒剂的陷阱
  -fno-语义插入

  -fno-short-enums
  -fno-short-wchar 强制 wchar_t 为无符号整数
  -fno-show-column 不要在诊断中包含列号
  -fno-show-source-location
                          不要在诊断中包含源位置信息
  -fno-signed-char 字符是无符号的
  -fno-signed-zeros 允许忽略浮点零符号的优化
  -fno-size-deallocation
  -fno-spell-checking 禁用拼写检查
  -fno-split-dwarf-inlining

  -fno-split-lto-unit
  -fno-split-machine-functions
                          使用配置文件信息禁用后期功能拆分 (x86 ELF)
  -fno-split-stack 不使用分段堆栈
  -fno-stack-clash-protection
                          禁用堆栈冲突保护
  -fno-stack-protector 禁用堆栈保护器
  -fno-stack-size-section
  -fno-standalone-debug 限制产生的调试信息以减少调试二进制文件的大小
  -fno-strict-float-cast-overflow
                          放宽语言规则并尝试匹配目标的原生 float-to-int 转换指令的行为
  -fno-strict-return 不要将脱离非空函数末尾的控制流路径视为不可达
  -fno-strict-vtable-pointers

  -fno-sycl 禁用设备的 SYCL 内核编译
  -fno-temp-file 直接创建编译输出文件。如果编译器崩溃，这可能会导致不正确的增量构建
  -fno-test-coverage
  -fno-threadsafe-statics 不要发出代码以使本地静态线程安全的初始化
  -fno-trigraphs 不处理三字母序列
  -fno-unique-basic-block-section-names

  -fno-unique-internal-linkage-names

  -fno-unique-section-names
                          不要为文本和数据部分使用唯一的名称
  -fno-unroll-loops 关闭循环展开器
  -fno-use-cxa-atexit 不要使用 __cxa_atexit 来调用析构函数
  -fno-use-init-array 使用 .ctors/.dtors 而不是 .init_array/.fini_array
  -fno-use-line-directives

  -fno-虚拟功能消除

  -fno-visibility-from-dllstorageclass

  -fno-visibility-inlines-hidden-static-local-var
                          禁用 -fvisibility-inlines-hidden-static-local-var（这是非达尔文目标的默认设置）
  -fno-visibility-inlines-hidden

  -fno-whole-program-vtables

  -fno-xl-pragma-pack
  -fno-xray-always-emit-customevents

  -fno-xray-always-emit-typedevents

  -fno-xray-function-index
                          以牺牲单功能补丁性能为代价省略功能索引部分
  -fno-xray-ignore-loops
  -fno-xray-仪器
  -fno-zero-initialized-in-bss
                          不要在 BSS 中放置零初始化数据
  -fno-zvector
  -fobjc-arc-exceptions 在 -fobjc-arc 中合成保留和释放时使用 EH 安全代码
  -fobjc-arc 合成对 Objective-C 指针的保留和释放调用
  -fobjc-convert-messages-to-runtime-calls

  -fobjc-disable-direct-methods-for-testing
                          忽略属性 objc_direct 以便可以测试直接方法
  -fobjc-encode-cxx-class-template-spec
                          完全编码 C++ 类模板特化
  -fobjc-exceptions 启用 Objective-C 异常
  -fobjc-infer-related-result-type

  -fobjc-runtime=<value> 指定目标 Objective-C 运行时种类和版本
  -fobjc-weak 在 Objective-C 中启用 ARC 风格的弱引用
  -foffload-lto=<value> 将 LTO 模式设置为“full”或“thin”以进行卸载编译
  -foffload-lto 在“完整”模式下启用 LTO 以进行卸载编译
  -fopenmp-simd 仅为基于 SIMD 的构造发出 OpenMP 代码。
  -fopenmp-target-new-runtime
                          使用新的位码库进行 OpenMP 卸载
  -fopenmp-targets=<值>
                          指定要支持的三元组 OpenMP 卸载目标的逗号分隔列表
  -fopenmp 解析 OpenMP 编译指示并生成并行代码。
  -foperator-names
  -foptimization-record-file=<文件>
                          指定包含优化注释的文件的输出名称。暗示 -fsave-optimization-record。在 Darwin 平台上，这不能与多个 -arch <arch> 选项一起使用。
  -foptimization-record-passes=<regex>
                          仅包含与生成的优化记录中指定的正则表达式匹配的传递（默认情况下，包括所有传递）
  -forder-file-instrumentation
                          生成检测代码以将订单文件收集到 default.profraw 文件中（由选项的“=”形式或 LLVM_PROFILE_FILE 环境变量覆盖）
  -fpack-struct=<value> 指定默认的最大结构体打包对齐
  -fpascal-strings 识别和构造 Pascal 风格的字符串文字
  -fpass-plugin=<dsopath> 从动态共享对象文件加载 pass 插件（仅适用于新的 pass 管理器）。
  -fpatchable-function-entry=<N,M>
                          函数入口前生成 M 个 NOP，函数入口后生成 N-M 个 NOP
  -fpcc-struct-return 覆盖默认 ABI 以返回堆栈上的所有结构
  -fpch-codegen 生成使用此 PCH 的代码，假定将为 PCH 构建显式目标文件
  -fpch-debuginfo 为从此 PCH 构建的目标文件中的类型生成调试信息，不要在其他地方生成它们
  -fpch-实例化模板
                          在构建 PCH 时已经实例化模板
  -fpch-validate-input-files-content
                          如果 mtime 不同，则根据内容验证 PCH 输入文件
  -fplt
  -fplugin=<dsopath> 加载命名插件（动态共享对象）
  -fprebuilt-隐式模块
                          在预建模块路径中查找隐式模块
  -fprebuilt-module-path=<目录>
                          指定预建模块路径
  -fpreserve-as-comments
  -fproc-stat-report=<值>
                          将子进程统计信息保存到给定文件
  -fproc-stat-report<值>
                          打印子进程统计信息
  -fprofile-arcs
  -fprofile-exclude-files=<值>
                          Instrument 仅从名称与所有以分号分隔的正则表达式不匹配的文件中运行
  -fprofile-filter-files=<值>
                          仪器仅从名称与任何以分号分隔的正则表达式匹配的文件中运行
  -fprofile-generate=<目录>
                          生成检测代码以将执行计数收集到 <directory>/default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fprofile-generate 生成检测代码以将执行计数收集到 default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fprofile-instr-generate=<文件>
                          生成检测代码以将执行计数收集到 <file>（由 LLVM_PROFILE_FILE env var 覆盖）
  -fprofile-instr-generate
                          生成检测代码以将执行计数收集到 default.profraw 文件中（由选项的“=”形式或 LLVM_PROFILE_FILE 环境变量覆盖）
  -fprofile-instr-use=<值>
                          使用检测数据进行配置文件引导的优化
  -fprofile-list=<value> 定义要检测的函数/文件列表的文件名
  -fprofile-remapping-file=<文件>
                          使用 <file> 中描述的重新映射将配置文件数据与程序中的名称进行匹配
  -fprofile-sample-accurate
                          指定样本配置文件是准确的
  -fprofile-sample-use=<值>
                          启用基于样本的配置文件引导优化
  -fprofile-update=<方法>
                          设置配置文件计数器的更新方法（atomic、prefer-atomic、single）
  -fprofile-use=<路径名>
                          使用检测数据进行配置文件引导的优化。如果 pathname 是一个目录，它从 <pathname>/default.profdata 中读取。否则，它从文件 <pathname> 中读取。
  -fprotect-parens 确定优化器在计算浮点表达式时是否使用括号
  -fpseudo-probe-for-profiling
                          发射用于样品分析的伪探针
  -freciprocal-math 允许重新关联除法运算
  -freg-struct-return 覆盖默认 ABI 以返回寄存器中的小结构
  -fregister-global-dtors-with-atexit
                          使用 atexit 或 __cxa_atexit 注册全局析构函数
  -frelaxed-template-template-args
                          启用 C++17 宽松模板模板参数匹配
  -freroll-loops 打开循环重滚器
  -frewrite-imports
  -frewrite-包括
  -fropi 生成只读位置无关代码（仅限 ARM）
  -frtlib-add-rpath 将带有体系结构特定资源目录的 -rpath 添加到链接器标志
  -frti-数据
  -frtti
  -frwpi 生成读写位置无关代码（仅限 ARM）
  -fsanitize-address-destructor=<值>
                          设置 ASan 检测中使用的析构函数类型
  -fsanitize-address-field-padding=<值>
                          AddressSanitizer 的字段填充级别
  -fsanitize-address-globals-dead-stripping
                          在 AddressSanitizer 中启用链接器对全局变量的死剥离
  -fsanitize-address-outline-instrumentation
                          始终为地址清理工具生成函数调用
  -fsanitize-address-poison-custom-array-cookie
                          在 AddressSanitizer 中使用自定义运算符 new[] 时启用中毒数组 cookie
  -fsanitize-address-use-after-return=<模式>
                          在AddressSanitizer中选择检测stack use-after-return的方式：never |运行时（默认） |总是
  -fsanitize-address-use-after-scope
                          在 AddressSanitizer 中启用作用域后检测
  -fsanitize-address-use-odr-indicator
                          启用 ODR 指标全局变量以避免在部分清理的程序中以增加二进制大小为代价的错误 ODR 违规报告
  -fsanitize-blacklist=<值>
                          -fsanitize-ignorelist= 的别名
  -fsanitize-cfi-canonical-jump-tables
                          使符号表中的跳转表地址成为规范
  -fsanitize-cfi-cross-dso
                          为跨 DSO 调用启用控制流完整性 (CFI) 检查。
  -fsanitize-cfi-ical-generalize-pointers
                          概括 CFI 间接调用类型签名检查中的指针
  -fsanitize-coverage-allowlist=<值>
                          将消毒剂覆盖检测仅限于与提供的特殊情况列表匹配的模块和功能，被阻止的除外
  -fsanitize-coverage-blacklist=<值>
                          已弃用，请改用 -fsanitize-coverage-ignorelist=
  -fsanitize-coverage-ignorelist=<值>
                          禁用与提供的特殊情况列表匹配的模块和功能的消毒剂覆盖检测，即使是允许的
  -fsanitize-coverage-whitelist=<值>
                          已弃用，请改用 -fsanitize-coverage-allowlist=
  -fsanitize-coverage=<值>
                          指定消毒剂的覆盖检测类型
  -fsanitize-hwaddress-abi=<值>
                          选择 HWAddressSanitizer ABI 为目标（拦截器或平台，默认拦截器）。此选项当前未使用。
  -fsanitize-hwaddress-experimental-aliasing
                          在 HWAddressSanitizer 中启用别名模式
  -fsanitize-ignorelist=<值>
                          消毒剂的忽略列表文件的路径
  -fsanitize-memory-track-origins=<值>
                          在 MemorySanitizer 中启用源跟踪
  -fsanitize-memory-track-origins
                          在 MemorySanitizer 中启用源跟踪
  -fsanitize-memory-use-after-dtor
                          在 MemorySanitizer 中启用销毁后使用检测
  -fsanitize-minimal-runtime

  -fsanitize-recover=<值>
                          为指定的消毒剂启用恢复
  -fsanitize-stats 启用 sanitizer 统计信息收集。
  -fsanitize-system-blacklist=<值>
                          -fsanitize-system-ignorelist= 的别名
  -fsanitize-system-ignorelist=<值>
                          消毒剂的系统忽略列表文件的路径
  -fsanitize-thread-atomics
                          在 ThreadSanitizer 中启用原子操作检测（默认）
  -fsanitize-thread-func-entry-exit
                          在 ThreadSanitizer 中启用函数进入/退出检测（默认）
  -fsanitize-thread-memory-access
                          在 ThreadSanitizer 中启用内存访问检测（默认）
  -fsanitize-trap=<value> 为指定的消毒剂启用陷阱
  -fsanitize-trap 为所有消毒剂启用捕获
  -fsanitize-undefined-strip-path-components=<编号>
                          在发出检查元数据时剥离（或仅保留，如果为负）一定数量的路径组件。
  -fsanitize=<check> 为各种形式的未定义或可疑行为打开运行时检查。有关可用检查，请参阅用户手册
  -fsave-optimization-record=<格式>
                          生成特定格式的优化记录文件
  -fsave-优化记录
                          生成 YAML 优化记录文件
  -fseh-exceptions 使用 SEH 风格的异常
  -fsemantic-interposition

  -fshort-enums 分配给枚举类型的字节数与声明的可能值范围所需的字节数相同
  -fshort-wchar 强制 wchar_t 是一个短的 unsigned int
  -fshow-列
  -fshow-overloads=<值>
                          当重载解析失败时显示哪些重载候选：最好|全部；默认为所有
  -fshow-skiped-includes 在 -H 输出中显示跳过的包含。
  -fshow-source-location
  -fsigned-char 字符已签名
  -fsigned-zeros
  -fsized-deallocation 启用 C++14 大小的全局释放函数
  -fsjlj-exceptions 使用 SjLj 样式的异常
  -fslp-vectorize 启用超字级并行向量化通道
  -f 拼写检查
  -fsplit-dwarf-inlining 在对象/可执行文件中提供最少的调试信息，以便在使用 Split DWARF 时在没有 .dwo/.dwp 文件的情况下促进在线符号化/堆栈跟踪
  -fsplit-lto-unit 启用 LTO 单元的拆分
  -fsplit-machine-functions
                          使用配置文件信息启用后期功能拆分 (x86 ELF)
  -fsplit-stack 使用分段堆栈
  -fstack-冲突保护
                          启用堆栈冲突保护
  -fstack-protector-all 为所有函数启用堆栈保护器
  -fstack-protector-strong
                          为某些易受堆栈粉碎的函数启用堆栈保护器。与 -fstack-protector 相比，它使用了更强的启发式方法，包括包含任何大小（和任何类型）数组的函数，以及对 alloca 的任何调用或从局部变量获取地址
  -fstack-protector 为一些易受堆栈粉碎的函数启用堆栈保护器。这使用了一种松散的启发式方法，如果函数包含字符（或 8 位整数）数组或对 alloca 的常量大小调用，它们的大小大于 ssp-buffer-size（默认值：8 字节），则该方法会认为函数易受攻击。所有对 alloca 的可变大小调用都被认为是易受攻击的。具有堆栈保护器的函数具有添加到堆栈帧的保护值，该值在函数退出时检查。保护值必须位于堆栈帧中，以便易受攻击的变量的缓冲区溢出将在覆盖函数的返回地址之前覆盖保护值。引用堆栈保护值存储在全局变量中。
  -fstack-size-section 发出包含函数堆栈大小元数据的部分
  -fstack-usage 发出包含函数堆栈大小信息的 .su 文件
  -fstandalone-debug 为程序使用的所有类型发出完整的调试信息
  -fstrict-enums 根据枚举值范围的严格定义启用优化
  -fstrict-float-cast-overflow
                          假设溢出的 float-to-int 类型转换未定义（默认）
  -fstrict-return
  -fstrict-vtable-pointers
                          根据覆盖多态 C++ 对象的严格规则启用优化
  -fsycl 为设备启用 SYCL 内核编译
  -fsystem-module 将此模块构建为系统模块。仅与 -emit-module 一起使用
  -ftest-coverage
  -fthin-link-bitcode=<值>
                          将最小化的位码写入 <file> 仅用于 ThinLTO 细链接
  -fthinlto-index=<value> 使用提供的函数摘要索引执行 ThinLTO 导入
  -fthreadsafe-statics
  -ftime-report=<value>（对于新通行证管理员）“per-pass”：每次通行证一份报告； “per-pass-run”：每次传递调用一份报告
  -ftime-trace-granularity=<值>
                          时间分析器跟踪的最小时间粒度（以微秒为单位）
  -ftime-trace 打开时间分析器。根据输出文件名生成 JSON 文件。
  -ftrap-function=<value> 发出对指定函数的调用而不是陷阱指令
  -ftrapv-handler=<函数名>
                          指定溢出时调用的函数
  -ftrapv 整数溢出陷阱
  -ftrigraphs 处理三字符序列
  -ftrivial-auto-var-init-stop-after=<值>
                          在指定数量的实例后停止初始化琐碎的自动堆栈变量
  -ftrivial-auto-var-init=<值>
                          初始化琐碎的自动堆栈变量：未初始化（默认）|图案
  -funique-basic-block-section-names
                          为基本块部分使用唯一的名称（仅限 ELF）
  -funique-internal-linkage-names
                          通过附加模块路径的 MD5 哈希来唯一化内部链接符号名称
  -funique-section-names
  -funroll-loops 打开循环展开器
  -fuse-cuid=<value> 为单源卸载语言 CUDA 和 HIP 的编译单元生成 ID 的方法：'hash'（通过散列文件路径和命令行选项生成的 ID）| 'random'（ID 生成为随机数）| “无”（禁用）。默认值为“哈希”。如果指定了该选项，则该选项将被选项 '-cuid=[ID]' 覆盖。
  -fuse-cxa-atexit
  -fuse-init-array
  -fuse-line-directives 在预处理输出中使用 #line
  -fvalidate-ast-input-files-content
                          计算并存储用于构建 AST 的输入文件的哈希值。如果两个内容相同，则 mtime 不匹配的文件被认为是有效的
  -fveclib=<value> 使用给定的向量函数库
  -fvectorize 启用循环矢量化过程
  -fverbose-asm 生成详细的汇编输出
  -f虚拟功能消除
                          启用死虚函数消除优化。需要 -flto=full
  -fvisibility-dllexport=<值>
                          dllexport 定义的可见性 [-fvisibility-from-dllstorageclass]
  -fvisibility-externs-dllimport=<值>
                          dllimport 外部声明的可见性 [-fvisibility-from-dllstorageclass]
  -fvisibility-externs-nodllstorageclass=<值>
                          没有显式 DLL dllstorageclass [-fvisibility-from-dllstorageclass] 的外部声明的可见性
  -fvisibility-from-dllstorageclass
                          从它们的 DLL 存储类设置生成代码中符号的可见性
  -fvisibility-global-new-delete-hidden
                          为全局 C++ 运算符提供 new 和 delete 声明隐藏可见性
  -fvisibility-inlines-hidden-static-local-var
                          启用 -fvisibility-inlines-hidden 时，内联 C++ 成员函数中的静态变量默认也会被赋予隐藏可见性
  -fvisibility-inlines-hidden
                          默认情况下为内联 C++ 成员函数提供隐藏可见性
  -fvisibility-ms-compat 默认给全局类型“默认”可见性和全局函数和变量“隐藏”可见性
  -fvisibility-nodllstorageclass=<值>
                          没有显式 DLL 导出类的定义的可见性 [-fvisibility-from-dllstorageclass]
  -fvisibility=<value> 为所有全局声明设置默认符号可见性
  -fwasm-exceptions 使用 WebAssembly 风格的异常
  -fwhole-program-vtables 启用整个程序 vtable 优化。需要 -flto
  -fwrapv 将有符号整数溢出视为二进制补码
  -fwritable-strings 将字符串文字存储为可写数据
  -fxl-pragma-pack 启用 IBM XL #pragma 包处理
  -fxray-always-emit-customevents
                          始终发出 __xray_customevent(...) 调用，即使包含的函数并不总是被检测
  -fxray-always-emit-typedevents
                          始终发出 __xray_typedevent(...) 调用，即使包含的函数并不总是被检测
  -fxray-always-instrument= <值>
                          已弃用：定义白名单的文件名，用于注入“始终仪器”X 射线属性。
  -fxray-attr-list= <值>
                          定义用于注入 XRay 属性的函数/类型列表的文件名。
  -fxray-function-groups=<值>
                          仅仪器 N 组中的 1
  -fxray-功能-索引
  -fxray-ignore-loops 不要用循环检测函数，除非它们也满足最小函数大小
  -fxray-instruction-threshold= <值>
                          设置最小函数大小以使用 XRay 进行检测
  -fxray-instrumentation-bundle= <值>
                          选择要发射的 XRay 仪器点。选项：全部、无、函数入口、函数出口、函数、自定义。默认为“全部”。 “功能”包括“功能入口”和“功能出口”。
  -fxray-instrument 在函数进入和退出时生成 XRay 仪器雪橇
  -fxray-link-deps 告诉 clang 添加 XRay 的链接依赖项。
  -fxray-modes= <value> 默认情况下链接到 XRay 检测二进制文件的模式列表。
  -fxray-never-instrument= <值>
                          已弃用：定义白名单的文件名，用于注入“从不使用”XRay 属性。
  -fxray-selected-function-group=<值>
                          使用 -fxray-function-groups 时，选择要检测的函数组。有效范围是 0 到 fxray-function-groups - 1
  -fzero-initialized-in-bss

  -fzvector 启用 System z 矢量语言扩展
  -F <value> 将目录添加到框架包括搜索路径
  --gcc-toolchain=<value> 在常用 GCC 的目标上的指定目录中搜​​索 GCC 安装。该目录通常包含“lib{,32,64}/gcc{,-cross}/$triple”和“include”。如果指定，则跳过 sysroot 以进行 GCC 检测。注意：编译器使用的可执行文件（例如 ld）不会被选定的 GCC 安装覆盖
  -gcodeview-ghash 在 .debug$H 部分发出类型记录哈希
  -gcodeview 生成 CodeView 调试信息
  -gcolumn-信息
  -gdwarf-2 使用 dwarf 版本 2 生成源级调试信息
  -gdwarf-3 使用 dwarf 版本 3 生成源级调试信息
  -gdwarf-4 使用 dwarf 版本 4 生成源级调试信息
  -gdwarf-5 使用 dwarf 版本 5 生成源级调试信息
  -gdwarf32 如果启用调试信息发射，则为 ELF 二进制文件启用 DWARF32 格式。
  -gdwarf64 如果启用调试信息发射，则为 ELF 二进制文件启用 DWARF64 格式。
  -gdwarf 使用默认的 dwarf 版本生成源级调试信息
  -gembed-source 在 DWARF 调试部分中嵌入源文本
  -ginline-line-tables
  -gline-directives-only 仅发出调试行信息指令
  -gline-tables-only 仅发出调试行号表
  -gmodules 使用外部引用来生成对 clang 模块或预编译头文件的调试信息
  -gno-codeview-ghash
  -gno 列信息
  -gno-embed-source 恢复在 DWARF 调试部分不嵌入源文本的默认行为
  -gno-inline-line-tables 不要发出内联行表。
  -gno-严格矮人
  --gpu-bundle-output 捆绑HIP设备编译的输出文件
  --gpu-instrument-lib=<值>
                          HIP 的仪器设备库，它是一个 LLVM 位码，包含 __cyg_profile_func_enter 和 __cyg_profile_func_exit
  --gpu-max-threads-per-block=<值>
                          HIP 内核启动边界的每块默认最大线程数
  -gsplit-dwarf=<value> 将 DWARF 裂变模式设置为 'split' 或 'single'
  -gstrict-矮人
  -gz=<值> DWARF 调试节压缩类型
  -G <size> 将最多 <size> 个字节的对象放入小数据段 (MIPS / Hexagon)
  -g 生成源码级调试信息
  --help-hidden 显示隐藏选项的帮助
  -help 显示可用选项
  --hip-device-lib=<值>
                          HIP 设备库
  --hip-link 用于 HIP 的链接 clang-offload-bundler 捆绑包
  --hip-path=<value> HIP 运行时安装路径，用于查找 HIP 版本和添加 HIP 包含路径。
  --hip-version=<value> 格式为major.minor.patch的HIP版本
  -H 显示标题包含和嵌套深度
  -I- 将所有先前的 -I 标志限制为双引号包含并从包含路径中删除当前目录
  -ibuiltininc 启用内置 #include 目录，即使在 -ibuiltininc 之前或之后使用 -nostdinc。在选项禁用它后使用 -nobuiltininc
  -idirafter <value> 将目录添加到 AFTER 包括搜索路径
  -iframeworkwithsysroot <目录>
                          添加目录到SYSTEM框架搜索路径，绝对路径相对于-isysroot
  -iframework <value> 将目录添加到 SYSTEM 框架搜索路径
  -imacros <file> 在解析前包含文件中的宏
  -include-pch <file> 包含预编译的头文件
  -include <file> 解析前包含文件
  -index-header-map 使下一个包含目录（-I 或 -F）成为索引器标题映射
  -iprefix <dir> 设置 -iwithprefix/-iwithprefixbefore 前缀
  -iquote <directory> 将目录添加到 QUOTE 包括搜索路径
  -isysroot <dir> 设置系统根目录（通常为/）
  -isystem-after <目录>
                          将目录添加到 SYSTEM 包含搜索路径的末尾
  -isystem <directory> 将目录添加到 SYSTEM 包括搜索路径
  -ivfsoverlay <value> 将 file 描述的虚拟文件系统覆盖在真实文件系统上
  -iwithprefixbefore <dir>
                          设置目录以包含带前缀的搜索路径
  -iwithprefix <dir> 将目录设置为 SYSTEM 包含带前缀的搜索路径
  -iwithsysroot <目录>
                          将目录添加到 SYSTEM 包含搜索路径，绝对路径相对于 -isysroot
  -I <dir> 将目录添加到包含搜索路径列表的末尾
  --libomptarget-amdgcn-bc-path=<值>
                          libomptarget-amdgcn 位码库的路径
  --libomptarget-nvptx-bc-path=<值>
                          libomptarget-nvptx 位码库的路径
  -L <dir> 将目录添加到库搜索路径
  -mabi=vec-default 在 AIX（仅限 AIX）上启用默认的 Altivec ABI。仅使用易失性向量寄存器。
  -mabi=vec-extabi 在 AIX（仅限 AIX）上启用扩展的 Altivec ABI。使用易失性和非易失性向量寄存器
  -mabicalls 启用 SVR4 样式的位置无关代码（仅限 Mips）
  -maix-struct-return 返回内存中的所有结构（仅限 PPC32）
  -malign-branch-boundary=<值>
                          指定边界的大小以对齐分支
  -malign-branch=<value> 指定要对齐的分支类型
  -malign-double 将双精度对齐到结构中的两个单词（仅限 x86）
  -mamdgpu-ieee 在预期的默认浮点模式寄存器中设置 IEEE 位。根据 IEEE 754-2008，支持异常标志收集安静和传播信号 NaN 输入的浮点操作码。此选项更改 ABI。 （仅限 AMDGPU）
  -mbackchain 通过 System Z 上的 backchain 链接堆栈帧
  -mbranch-protection=<值>
                          强制执行间接分支和函数返回的目标
  -32B 边界内的分支
                          在 32 字节边界内对齐选定的分支（融合、jcc、jmp）
  -mcmodel=medany 相当于-mcmodel=medium，兼容RISC-V gcc。
  -mcmodel=medlow 相当于-mcmodel=small，兼容RISC-V gcc。
  -mcmse 允许使用 CMSE（Armv8-M 安全扩展）
  -mcode-object-v3 指定代码对象 ABI V3 的传统选项（仅限 AMDGPU）
  -mcode-object-version=<版本>
                          指定代码对象 ABI 版本。默认为 3。（仅限 AMDGPU）
  -mcrc 允许使用 CRC 指令（仅限 ARM/Mips）
  -mcumode 指定 CU 波前执行模式（仅限 AMDGPU）
  -mdouble=<value> 强制双精度为 32 位或 64 位
  -MD 写一个包含用户和系统头文件的 depfile
  -meabi <value> 设置 EABI 类型，例如4、5 或 gnu（默认取决于三元组）
  -membedded-data 将常量放在 .rodata 部分而不是 .sdata 部分，即使它们满足 -G <size> 阈值 (MIPS)
  -menable-experimental-extensions
                          启用实验性 RISC-V 扩展的使用。
  -menable-unsafe-fp-math 允许不安全的浮点数学优化，这可能会降低精度
  -mexec-model=<value> 执行模型（仅限 WebAssembly）
  -mexecute-only 禁止生成对代码段的数据访问（仅限 ARM）
  -mextern-sdata 如果满足 -G <size> 阈值 (MIPS)，则假设外部定义的数据在小数据中
  -mfentry 在函数入口处插入对 fentry 的调用（仅限 x86/SystemZ）
  -mfix-cortex-a53-835769 解决方法 Cortex-A53 勘误表 835769（仅限 AArch64）
  -mfp32 使用 32 位浮点寄存器（仅限 MIPS）
  -mfp64 使用 64 位浮点寄存器（仅限 MIPS）
  -MF <file> 将 depfile 输出从 -MMD、-MD、-MM 或 -M 写入 <file>
  -mgeneral-regs-only 生成仅使用通用寄存器的代码（仅限 AArch64/x86）
  -mglobal-merge 启用全局变量的合并
  -mgpopt 对已知位于小数据节 (MIPS) 中的符号使用 GP 相对访问
  -MG 将缺失的头文件添加到 depfile
  -mharden-sls=<value> 选择直线推测强化范围
  -mhvx-length=<value> 设置六边形矢量长度
  -mhvx=<value> 启用六边形矢量扩展
  -mhvx 启用六边形矢量扩展
  -miamcu 使用英特尔 MCU ABI
  -mignore-xcoff-visibility
                          不在 AIX OS 中为 asm 发出可见性属性或在 XCOFF 对象文件中为所有符号提供“未指定”可见性
  --migrate 运行迁移器
  -mincremental-linker 兼容
                          (integrated-as) 发出可与增量链接器一起使用的目标文件
  -mindirect-jump=<value> 更改间接跳转指令以抑制推测
  -mios-version-min=<值>
                          设置 iOS 部署目标
  -MJ <value> 为每个输入写入一个编译数据库条目
  -mllvm <value> 转发到 LLVM 选项处理的附加参数
  -mlocal-sdata 将 -G 行为扩展到对象本地数据 (MIPS)
  -mlong-calls 生成具有扩展寻址能力的分支，通常通过间接跳转。
  -mlong-double-128 强制 long double 为 128 位
  -mlong-double-64 强制 long double 为 64 位
  -mlong-double-80 强制 long double 为 80 位，填充为 128 位用于存储
  -mlvi-cfi 仅启用负载值注入 (LVI) 的控制流缓解措施
  -mlvi-hardening 启用负载值注入 (LVI) 的所有缓解措施
  -mmacosx-version-min=<值>
                          设置 Mac OS X 部署目标
  -mmadd4 启用生成 4 操作数的 madd.s、madd.d 和相关指令。
  -mmark-bti-property 将带有 BTI 的 .note.gnu.property 添加到程序集文件（仅限 AArch64）
  -MMD 写一个包含用户头信息的 depfile
  -mmemops 启用 memop 指令的生成
  -mms-bitfields 设置默认结构布局以兼容微软编译器标准
  -mmsa 启用 MSA ASE（仅限 MIPS）
  -mmt 启用 MT ASE（仅限 MIPS）
  -MM 与 -MMD 类似，但也隐含 -E 并默认写入标准输出
  -mno-abicalls 禁用 SVR4 样式的位置无关代码（仅限 Mips）
  -mno-amdgpu-ieee
  -mno-backchain
  -mno-code-object-v3 指定代码对象 ABI V2 的传统选项（仅限 AMDGPU）
  -mno-crc 禁止使用 CRC 指令（仅限 Mips）
  -mno-cumode 指定 WGP 波前执行模式（仅限 AMDGPU）
  -mno-embedded-data 如果常量满足 -G <size> 阈值 (MIPS)，则不要将常量放在 .rodata 部分而不是 .sdata
  -mno-execute-only 允许生成对代码段的数据访问（仅限 ARM）
  -mno-extern-sdata 如果满足 -G <size> 阈值 (MIPS)，则不要假设外部定义的数据在小数据中
  -mno-fix-cortex-a53-835769
                          不要解决 Cortex-A53 勘误表 835769（仅限 AArch64）
  -mno-global-merge 禁用全局变量的合并
  -mno-gpopt 不要对已知位于小数据节 (MIPS) 中的符号使用 GP 相对访问
  -mno-hvx 禁用六边形矢量扩展
  -mno-implicit-float 不生成隐式浮点指令
  -mno-增量-链接器兼容
                          (integrated-as) 发出不能与增量链接器一起使用的目标文件
  -mno-local-sdata 不要将 -G 行为扩展到对象本地数据 (MIPS)
  -mno-long-calls 恢复不生成长调用的默认行为
  -mno-lvi-cfi 禁用负载值注入 (LVI) 的控制流缓解措施
  -mno-lvi-hardening 禁用负载值注入 (LVI) 的缓解措施
  -mno-madd4 禁止生成 4 操作数 madd.s、madd.d 及相关指令。
  -mno-memops 禁用 memop 指令的生成
  -mno-movt 禁止使用 movt/movw 对（仅限 ARM）
  -mno-ms-bitfields 不要将默认结构布局设置为与 Microsoft 编译器标准兼容
  -mno-msa 禁用 MSA ASE（仅限 MIPS）
  -mno-mt 禁用 MT ASE（仅限 MIPS）
    -mno-neg-immediates 禁止将带有负立即数的指令转换为它们的否定或反转。
  -mno-nvj 禁用新值跳转的生成
  -mno-nvs 禁用新值存储的生成
  -mno-outline-atomics 不生成对外部原子操作的本地调用
  -mno-outline 禁用函数大纲（仅限 AArch64）
  -mno-packets 禁用指令包的生成
  -mno-relax 禁用链接器松弛
  -mno-restrict-it 允许为 ARMv8 生成已弃用的 IT 块。 ARMv8 Thumb 模式默认关闭
  -mno-save-restore 禁用使用库调用进行保存和恢复
  -mno-seses 禁用推测执行副作用抑制 (SESES)
  -mno-speculative-load-hardening

  -mno-stack-arg-probe 禁用默认启用的堆栈探测
  -mno-tgsplit 禁用线程组拆分执行模式（仅限 AMDGPU）
  -mno-tls-direct-seg-refs
                          通过段寄存器禁用直接 TLS 访问
  -mno-unaligned-access 强制对齐所有内存访问（仅限 AArch32/AArch64）
  -mno-unsafe-fp-atomics
  -mno-wavefrontsize64 指定波前大小 32 模式（仅限 AMDGPU）
  -mnocrc 禁止使用 CRC 指令（仅限 ARM）
  -mnop-mcount 生成 mcount/__fentry__ 调用作为 nops。要激活它们，需要修补。
  -mnvj 启用新值跳转的生成
  -mnvs 启用新值存储的生成
  -module-dependency-dir <值>
                          将模块依赖项转储到的目录
  -module-file-info 提供有关特定模块文件的信息
  -momit-leaf-frame-pointer
                          省略叶函数的帧指针设置
  -moutline-atomics 生成对外部原子操作的本地调用
  -moutline 启用功能大纲（仅限 AArch64）
  -mpacked-stack 使用打包堆栈布局（仅限 SystemZ）。
  -mpackets 启用指令包的生成
  -mpad-max-prefix-size=<值>
                          指定用于填充的最大前缀数
  -mprefer-vector-width=<值>
                          指定用于自动矢量化的首选矢量宽度。默认为“无”，允许针对特定目标做出决定。
  -MP 为每个依赖项创建虚假目标（主文件除外）
  -mqdsp6-compat 启用六边形-qdsp6 向后兼容性
  -MQ <value> 指定要在 depfile 中引用的主文件输出的名称
  -mrecord-mcount 为每个 __fentry__ 调用生成一个 __mcount_loc 部分条目。
  -mrelax-all (integrated-as) 放宽所有机器指令
  -mrelax 启用链接器松弛
  -mrestrict-it 禁止为 ARMv8 生成已弃用的 IT 块。默认情况下，它在 ARMv8 Thumb 模式下处于启用状态。
  -mrtd 将 StdCall 调用约定设为默认值
  -msave-restore 启用使用库调用进行保存和恢复
  -mseses 启用推测执行副作用抑制 (SESES)。包括 LVI 控制流完整性缓解措施
  -msign-return-address=<值>
                          选择返回地址签名范围
  -msmall-data-limit=<值>
                          将小于限制的全局和静态数据放入一个特殊的部分
  -msoft-float 使用软件浮点数
  -mspeculative-load-hardening

  -mstack-alignment=<值>
                          设置堆栈对齐
  -mstack-arg-probe 启用堆栈探测
  -mstack-probe-size=<值>
                          设置堆栈探针大小
  -mstack-protector-guard-offset=<值>
                          使用给定的偏移量来寻址堆栈保护器防护
  -mstack-protector-guard-reg=<值>
                          使用给定的 reg 来解决堆栈保护器防护
  -mstack-protector-guard=<值>
                          使用给定的保护（全局，tls）来解决堆栈保护器保护
  -mstackrealign 强制在每个函数的入口重新对齐堆栈
  -msve-vector-bits=<值>
                          以位为单位指定 SVE 矢量寄存器的大小。默认为“可缩放”的向量长度不可知值。 （仅限 AArch64）
  -msvr4-struct-return 返回寄存器中的小结构（仅限 PPC32）
  -mtgsplit 启用线程组拆分执行模式（仅限 AMDGPU）
  -mthread-model <value> 要使用的线程模型，例如posix，单（默认为posix）
  -mtls-direct-seg-refs 通过段寄存器启用直接 TLS 访问（默认）
  -mtls-size=<value> 指定立即 TLS 偏移的位大小（仅限 AArch64 ELF）：12（4KB）| 24（16MB，默认）| 32（4GB）| 48（对于 256TB，需要 -mcmodel=large）
  -mtp=<value> 线程指针访问方法（仅限 AArch32/AArch64）
  -mtune=<value> 仅在 X86 和 RISC-V 上受支持。否则接受与 GCC 的兼容性。
  -MT <value> 指定 depfile 中主文件输出的名称
  -munaligned-access 允许未对齐的内存访问（仅限 AArch32/AArch64）
  -munsafe-fp-atomics 启用不安全的浮点原子指令（仅限 AMDGPU）
  -MV 对 depfile 使用 NMake/Jom 格式
  -mwavefrontsize64 指定波前大小 64 模式（仅限 AMDGPU）
  -M 与 -MD 类似，但也暗示 -E 并默认写入标准输出
  --no-cuda-include-ptx=<值>
                          以下GPU架构（例如sm_35）或'all'不要包含PTX。可以多次指定。
  --no-cuda-version-check 如果检测到的 CUDA 安装版本对于请求的 CUDA gpu 架构来说太低，不要出错。
  --no-gpu-bundle-output 不捆绑HIP设备编译的输出文件
  --no-offload-arch=<值>
                          从要编译的设备列表中删除 CUDA/HIP 卸载设备架构（例如 sm_35、gfx906）。 'all' 将列表重置为其默认值。
  -无线程
  --no-system-header-prefix=<前缀>
                          将所有以 <prefix> 开头的 #include 路径视为不包括系统标头。
  -nobuiltininc 禁用内置 #include 目录
  -nogpuinc 不为 CUDA/HIP 添加包含路径，也不包含默认的 CUDA/HIP 包装头
  -nogpulib 不要为 CUDA/HIP 设备编译链接设备库
  -nostdinc++ 禁用 C++ 标准库的标准 #include 目录
  -ObjC++ 将源输入文件视为 Objective-C++ 输入
  -objcmt-atomic-property 迁移到“原子”属性
  -objcmt-migrate-all 启用迁移到现代 ObjC
  -objcmt-migrate-annotation
                          启用迁移到属性和方法注释
  -objcmt-migrate-designated-init
                          启用迁移以推断初始化方法的 NS_DESIGNATED_INITIALIZER
  -objcmt-migrate-instancetype
                          启用迁移以推断方法结果类型的实例类型
  -objcmt-migrate-literals
                          启用迁移到现代 ObjC 文字
  -objcmt-migrate-ns-macros
                          启用迁移到 NS_ENUM/NS_OPTIONS 宏
  -objcmt-migrate-property-dot-syntax
                          启用 setter/getter 消息到属性点语法的迁移
  -objcmt-migrate-property
                          启用迁移到现代 ObjC 属性
  -objcmt-migrate-protocol-conformance
                          启用迁移以在类上添加协议一致性
  -objcmt-migrate-readonly-property
                          启用迁移到现代 ObjC 只读属性
  -objcmt-migrate-readwrite-property
                          启用迁移到现代 ObjC 读写属性
  -objcmt-migrate-subscripting
                          支持迁移到现代 ObjC 下标
  -objcmt-ns-nonatomic-iosonly
                          启用迁移以使用 NS_NONATOMIC_IOSONLY 宏来设置属性的“原子”属性
  -objcmt-returns-innerpointer-property
                          启用迁移以使用 NS_RETURNS_INNER_POINTER 注释属性
  -objcmt-whitelist-dir-path=<值>
                          只修改文件名包含在提供的目录路径中的文件
  -ObjC 将源输入文件视为 Objective-C 输入
  --offload-arch=<value> CUDA 卸载设备架构（例如 sm_35），或 HIP 卸载目标 ID，其形式为设备架构后跟以冒号分隔的目标 ID 特征。每个目标 ID 特征都是一个预定义的字符串，后跟一个加号或减号（例如 gfx908:xnack+:ramecc-）。可以多个指定。
  -o <file> 将输出写入 <file>
  - 迂腐警告语言扩展
  -pg 启用 mcount 检测
  -pipe 尽可能在命令之间使用管道
  --precompile 只预编译输入
  -print-effective-triple 打印有效的目标三元组
  -print-file-name=<file> 打印 <file> 的完整库路径
  -print-ivar-layout 启用 Objective-C Ivar 布局位图打印跟踪
  -print-libgcc-file-name 打印当前使用的编译器运行时库的库路径（“libgcc.a”或“libclang_rt.builtins.*.a”）
  -print-multiarch 打印多架构目标三元组
  -print-prog-name=<name> 打印 <name> 的完整程序路径
  -print-resource-dir 打印资源目录路径名
  -print-rocm-search-dirs 打印用于查找 ROCm 安装的路径
  -print-runtime-dir 打印包含 clangs 运行时库的目录路径名
  -print-search-dirs 打印用于查找库和程序的路径
  -print-supported-cpus 为给定目标打印支持的 CPU 模型（如果未指定目标，它将打印默认目标支持的 CPU）
  -print-target-triple 打印标准化的目标三元组
  -print-targets 打印注册的目标
  -pthread 在生成的代码中支持 POSIX 线程
  --ptxas-path=<value> ptxas 的路径（用于编译 CUDA 代码）
  -P 在 -E 模式下禁用 linemarker 输出
  -Qn 不发出包含编译器名称和版本的元数据
  -Qunused-arguments 不要为未使用的驱动程序参数发出警告
  -Qy 发出包含编译器名称和版本的元数据
  -relocatable-pch 是否构建可重定位的预编译头
  -rewrite-legacy-objc 将旧版 Objective-C 源代码重写为 C++
  -rewrite-objc 将 Objective-C 源代码重写为 C++
  --rocm-device-lib-path=<值>
                          ROCm 设备库路径。替代 rocm-path。
  --rocm-path=<value> ROCm 安装路径，用于查找和自动链接所需的位码库。
  -Rpass-analysis=<value> 报告来自名称与给定 POSIX 正则表达式匹配的优化通道的转换分析
  -Rpass-missed=<value> 通过名称与给定 POSIX 正则表达式匹配的优化传递报告丢失的转换
  -Rpass=<value> 报告由名称与给定 POSIX 正则表达式匹配的优化通道执行的转换
  -rtlib=<value> 要使用的编译器运行时库
  -R<remark> 启用指定的备注
  -save-stats=<value> 保存 llvm 统计信息。
  -save-stats 保存 llvm 统计信息。
  -save-temps=<value> 保存中间编译结果。
  -save-temps 保存中间编译结果
  -serialize-diagnostics <值>
                          将编译器诊断序列化为文件
  -shared-libsan 动态链接 sanitizer 运行时
  -static-libsan 静态链接消毒剂运行时
  -static-openmp 链接时使用静态主机 OpenMP 运行时。
  -std=<value> 要编译的语言标准
  -stdlib++-isystem <目录>
                          使用目录作为 C++ 标准库包含路径
  -stdlib=<value> 要使用的 C++ 标准库
  -sycl-std=<value> 要编译的 SYCL 语言标准。
  --system-header-prefix=<前缀>
                          将所有以 <prefix> 开头的 #include 路径视为包含系统标头。
  -S 只运行预处理和编译步骤
  --target=<value> 为给定目标生成代码
  -Tbss <addr> 设置BSS的起始地址为<addr>
  -Tdata <addr> 设置DATA的起始地址为<addr>
  -time 时间单个命令
  -traditional-cpp 启用一些传统的 CPP 仿真
  -trigraphs 处理三字符序列
  -Ttext <addr> 设置 TEXT 的起始地址为 <addr>
  -T <script> 指定 <script> 作为链接器脚本
  -undef undef 所有系统定义
  -unwindlib=<value> 要使用的展开库
  -U <macro> 取消定义宏 <macro>
  --verify-debug-info 验证调试输出的二进制表示
  -verify-pch 加载并验证预编译的头文件是否过时
  --version 打印版本信息
  -v 显示运行和使用详细输出的命令
  -Wa,<arg> 将 <arg> 中逗号分隔的参数传递给汇编器
  -Wdeprecated 为已弃用的构造启用警告并定义 __DEPRECATED
  -Wl,<arg> 将 <arg> 中逗号分隔的参数传递给链接器
  -working-directory <值>
                          解析相对于指定目录的文件路径
  -Wp,<arg> 将 <arg> 中逗号分隔的参数传递给预处理器
  -W<warning> 启用指定的警告
  -w 禁止所有警告
  -Xanalyzer <arg> 将 <arg> 传递给静态分析器
  -Xarch_device <arg> 将 <arg> 传递给 CUDA/HIP 设备编译
  -Xarch_host <arg> 将 <arg> 传递给 CUDA/HIP 主机编译
  -Xassembler <arg> 将 <arg> 传递给汇编器
  -Xclang <arg> 将 <arg> 传递给 clang 编译器
  -Xcuda-fatbinary <arg> 将 <arg> 传递给 fatbinary 调用
  -Xcuda-ptxas <arg> 将 <arg> 传递给 ptxas 汇编程序
  -Xlinker <arg> 将 <arg> 传递给链接器
  -Xopenmp-target=<triple> <arg>
                          将 <arg> 传递给由 <triple> 标识的目标卸载工具链。
  -Xopenmp-target <arg> 将 <arg> 传递给目标卸载工具链。
  -Xpreprocessor <arg> 将 <arg> 传递给预处理器
  -x <language> 将后续输入文件视为具有 <language> 类型
  -z <arg> 将 -z <arg> 传递给链接器
